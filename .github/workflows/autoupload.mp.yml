name: Anaconda Build & Upload

on:
  push:
    branches: ['**']
    tags: ['*']

jobs:
  env:
    runs-on: ubuntu-latest
    outputs:
      COMMIT_SHA:         ${{ steps.git.outputs.COMMIT_SHA }}
      COMMIT_LATEST_TAG:  ${{ steps.git.outputs.COMMIT_LATEST_TAG }}
      COMMIT_TAG:         ${{ steps.git.outputs.COMMIT_TAG }}
      COMMIT_VERSION:     ${{ steps.git.outputs.COMMIT_VERSION }}
      COMMIT_TYPE:        ${{ steps.git.outputs.COMMIT_TYPE }}
      ANACONDA_LABEL:     ${{ steps.anaconda.outputs.ANACONDA_LABEL }}
      ANACONDA_VERSION:   ${{ steps.anaconda.outputs.ANACONDA_VERSION }}
      ANACONDA_PACKAGE:   ${{ steps.anaconda.outputs.ANACONDA_PACKAGE }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - id: git
        run: |
          set -e
          COMMIT_SHA=$(git rev-parse HEAD || exit 1)
          echo "COMMIT_SHA=$COMMIT_SHA" >> "$GITHUB_OUTPUT"

          COMMIT_LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          [ -n "$COMMIT_LATEST_TAG" ] && echo "COMMIT_LATEST_TAG=$COMMIT_LATEST_TAG" >> "$GITHUB_OUTPUT"

          if [ "$GITHUB_REF_TYPE" = "tag" ]; then
            COMMIT_TAG="$GITHUB_REF_NAME"
            echo "COMMIT_TAG=$COMMIT_TAG" >> "$GITHUB_OUTPUT"
          else
            echo "COMMIT_TYPE=dev" >> "$GITHUB_OUTPUT"
          fi

          COMMIT_VERSION="${COMMIT_TAG:-${COMMIT_LATEST_TAG}}"
          [ -n "$COMMIT_VERSION" ] && echo "COMMIT_VERSION=$COMMIT_VERSION" >> "$GITHUB_OUTPUT"

      - id: anaconda
        run: |
          set -e
          [ -n "${{ steps.git.outputs.COMMIT_TYPE }}" ] && CT="-${{ steps.git.outputs.COMMIT_TYPE }}" || CT=""
          CV="${{ steps.git.outputs.COMMIT_VERSION }}"
          if [[ "$CV" == *-* ]]; then
            ANACONDA_LABEL="${CV#*-}"
          else
            ANACONDA_LABEL="main"
          fi
          ANACONDA_PACKAGE=$(basename "$(git rev-parse --show-toplevel)" | sed 's,-feedstock,,g')
          ANACONDA_VERSION="${CV//-/.}"
          ANACONDA_VERSION="${ANACONDA_VERSION:-0.0.0}${CT//-/.}"

          {
            echo "ANACONDA_PACKAGE=$ANACONDA_PACKAGE"
            echo "ANACONDA_LABEL=$ANACONDA_LABEL"
            echo "ANACONDA_VERSION=$ANACONDA_VERSION"
          } >> "$GITHUB_OUTPUT"

  prepare:
      runs-on: ubuntu-latest
      needs: env
      outputs:
        matrix: ${{ steps.mk.outputs.matrix }}
      steps:
        - uses: actions/checkout@v4
  
        - name: Setup Miniconda (prepare)
          uses: conda-incubator/setup-miniconda@v2
          with:
            auto-update-conda: true
            activate-environment: true
            python-version: "3.11"
            auto-activate-base: true
  
        - name: Install conda-build + jq
          shell: bash -l {0}
          run: |
            conda install -y -c conda-forge conda-build jq
  
        - id: mk
          name: Render recipe -> GHA matrix (JSON only)
          shell: bash -l {0}
          run: |
            set -euo pipefail
            # Render variants to JSON (stdout only), silence chatter on stderr
            conda render recipe --json > render.json 2>/dev/null
  
            # Build a compact {include:[...]} matrix with the keys you care about
            jq -c '
              [ .[] 
                | { 
                    root: (.config.variant.root|tostring),
                    c_stdlib: .config.variant.c_stdlib,
                    c_stdlib_version: (.config.variant.c_stdlib_version|tostring)
                  }
              ]
              | unique
              | { include: . }
            ' render.json > matrix.json
  
            # Export a single-line JSON into GITHUB_OUTPUT
            MATRIX=$(tr -d "\n" < matrix.json)
            echo "matrix=$MATRIX" >> "$GITHUB_OUTPUT"
            
  build:
    runs-on: ubuntu-latest
    needs: [env, prepare]
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.prepare.outputs.matrix) }}
    env:
      ANACONDA_PACKAGE: ${{ needs.env.outputs.ANACONDA_PACKAGE }}
      ANACONDA_VERSION: ${{ needs.env.outputs.ANACONDA_VERSION }}
      ANACONDA_LABEL:   ${{ needs.env.outputs.ANACONDA_LABEL }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup micromamba
        uses: mamba-org/setup-micromamba@v2
        with:
          micromamba-version: "latest"
          generate-run-shell: true
          cache-environment: true
          environment-file: |
            name: build
            channels: [conda-forge, defaults, hep-forge]
            dependencies:
              - python
              - conda-build
              - boa
              - anaconda-client
              - conda-package-handling
              - ccache
              - pkg-config

      - name: Cache conda-bld
        uses: actions/cache@v4
        with:
          path: ~/micromamba/conda-bld
          key: conda-bld-${{ runner.os }}-${{ hashFiles('recipe/**') }}-${{ matrix.root }}

      - name: Configure ccache
        run: |
          mkdir -p ~/.ccache
          {
            echo "max_size = 2G"
            echo "compiler_check = content"
          } > ~/.ccache/ccache.conf
          echo "CCACHE_DIR=$HOME/.ccache" >> $GITHUB_ENV
          echo "CCACHE_BASEDIR=$GITHUB_WORKSPACE" >> $GITHUB_ENV
          echo "CC='ccache gcc'"  >> $GITHUB_ENV
          echo "CXX='ccache g++'" >> $GITHUB_ENV
          echo "CMAKE_CXX_COMPILER_LAUNCHER=ccache" >> $GITHUB_ENV
          echo "CMAKE_C_COMPILER_LAUNCHER=ccache"   >> $GITHUB_ENV

      - name: Build (one CBC variant)
        shell: bash -l {0}
        run: |
          set -euo pipefail
          VAR_JSON=$(jq -nc \
            --arg root "${{ matrix.root }}" \
            --arg c_stdlib "${{ matrix.c_stdlib }}" \
            --arg c_stdlib_version "${{ matrix.c_stdlib_version }}" \
            '{root: [$root], c_stdlib: [$c_stdlib], c_stdlib_version: [$c_stdlib_version]}')
          echo "Selected variant: $VAR_JSON"
          mamba mambabuild recipe --variants "$VAR_JSON" --output-folder pkgs

          # Optional: convert tarballs to .conda for upload
          for PKG in $(find pkgs -name "*.tar.bz2"); do
            conda convert --platform linux-64 "$PKG" -o pkgs >/dev/null 2>&1 || true
          done

      - uses: actions/upload-artifact@v4
        with:
          name: conda-packages-${{ matrix.root }}
          path: pkgs/**/*
          if-no-files-found: error

  publish:
    runs-on: ubuntu-latest
    needs: [env, build]
    steps:
      - uses: actions/download-artifact@v4
        with:
          pattern: conda-packages-*
        # merge-multiple: true isn't supported by v4, artifacts will download under their own dirs
          path: pkgs

      - name: Setup micromamba (client)
        uses: mamba-org/setup-micromamba@v2
        with:
          micromamba-version: "latest"
          generate-run-shell: true
          environment-file: |
            name: upload
            channels: [conda-forge]
            dependencies: [anaconda-client]

      - name: Upload to Anaconda
        env:
          ANACONDA_LABEL:   ${{ needs.env.outputs.ANACONDA_LABEL }}
          ANACONDA_PACKAGE: ${{ needs.env.outputs.ANACONDA_PACKAGE }}
          ANACONDA_VERSION: ${{ needs.env.outputs.ANACONDA_VERSION }}
          ANACONDA_API_TOKEN: ${{ secrets.ANACONDA_API_TOKEN }}
        shell: bash -l {0}
        run: |
          set -euo pipefail
          [ -z "$ANACONDA_VERSION" ] && exit 1
          find pkgs -type f -name "*.conda" -print0 | while IFS= read -r -d '' CONDA; do
            anaconda -t "$ANACONDA_API_TOKEN" upload --force "$CONDA" --label "$ANACONDA_LABEL"
          done

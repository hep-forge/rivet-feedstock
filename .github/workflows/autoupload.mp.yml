name: Anaconda Build & Upload

on:
  push:
    branches: ['**']
    tags: ['*']

jobs:
  env:
    runs-on: ubuntu-latest
    outputs:
      COMMIT_SHA:         ${{ steps.git.outputs.COMMIT_SHA }}
      COMMIT_LATEST_TAG:  ${{ steps.git.outputs.COMMIT_LATEST_TAG }}
      COMMIT_TAG:         ${{ steps.git.outputs.COMMIT_TAG }}
      COMMIT_VERSION:     ${{ steps.git.outputs.COMMIT_VERSION }}
      COMMIT_TYPE:        ${{ steps.git.outputs.COMMIT_TYPE }}
      ANACONDA_LABEL:     ${{ steps.anaconda.outputs.ANACONDA_LABEL }}
      ANACONDA_VERSION:   ${{ steps.anaconda.outputs.ANACONDA_VERSION }}
      ANACONDA_PACKAGE:   ${{ steps.anaconda.outputs.ANACONDA_PACKAGE }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - id: git
        run: |
          set -e
          COMMIT_SHA=$(git rev-parse HEAD || exit 1)
          echo "COMMIT_SHA=$COMMIT_SHA" >> "$GITHUB_OUTPUT"

          COMMIT_LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -n "$COMMIT_LATEST_TAG" ]; then
            echo "COMMIT_LATEST_TAG=$COMMIT_LATEST_TAG" >> "$GITHUB_OUTPUT"
          fi

          if [ "$GITHUB_REF_TYPE" = "tag" ]; then
            COMMIT_TAG="$GITHUB_REF_NAME"
            echo "COMMIT_TAG=$COMMIT_TAG" >> "$GITHUB_OUTPUT"
          else
            echo "COMMIT_TYPE=dev" >> "$GITHUB_OUTPUT"
          fi

          COMMIT_VERSION="${COMMIT_TAG:-${COMMIT_LATEST_TAG}}"
          if [ -n "$COMMIT_VERSION" ]; then
            echo "COMMIT_VERSION=$COMMIT_VERSION" >> "$GITHUB_OUTPUT"
          fi

      - id: anaconda
        run: |
          set -e
          CT="${{ steps.git.outputs.COMMIT_TYPE }}"
          [ -n "$CT" ] && CT="-$CT" || CT=""
          CV="${{ steps.git.outputs.COMMIT_VERSION }}"

          if [[ "$CV" == *-* ]]; then
            ANACONDA_LABEL="${CV#*-}"
          else
            ANACONDA_LABEL="main"
          fi

          ANACONDA_PACKAGE=$(basename "$(git rev-parse --show-toplevel)" | sed 's,-feedstock,,g')
          ANACONDA_VERSION="${CV//-/.}"
          ANACONDA_VERSION="${ANACONDA_VERSION:-0.0.0}${CT//-/.}"

          {
            echo "ANACONDA_PACKAGE=$ANACONDA_PACKAGE"
            echo "ANACONDA_LABEL=$ANACONDA_LABEL"
            echo "ANACONDA_VERSION=$ANACONDA_VERSION"
          } >> "$GITHUB_OUTPUT"

  prepare:
    runs-on: ubuntu-latest
    needs: env
    outputs:
      matrix: ${{ steps.mk.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Miniconda (prepare)
        uses: conda-incubator/setup-miniconda@v2
        with:
          auto-update-conda: true
          activate-environment: true     # activates default base safely
          python-version: "3.11"
          auto-activate-base: true

      - name: Install conda-build + jq
        shell: bash -l {0}
        run: |
          conda install -y -c conda-forge conda-build jq

      - id: mk
        name: Render recipe -> GHA matrix (JSON only)
        shell: bash -l {0}
        run: |
          set -Eeuo pipefail

          RECIPE_DIR=${RECIPE_DIR:-recipe}
          if [ ! -d "$RECIPE_DIR" ]; then
            echo "::error::No '$RECIPE_DIR/' directory at repo root."
            ls -la
            exit 1
          fi

          # Render variants to JSON; silence chatter
          if ! conda render "$RECIPE_DIR" --json > render.json 2> render.stderr; then
            echo "::group::conda render stderr"
            cat render.stderr || true
            echo "::endgroup::"
            exit 1
          fi

          # Build a compact {include:[...]} matrix using your CBC keys
          if ! jq -e -c '
            [ .[]
              | {
                  root: (.config.variant.root|tostring),
                  c_stdlib: .config.variant.c_stdlib,
                  c_stdlib_version: (.config.variant.c_stdlib_version|tostring)
                }
            ] | unique | { include: . }
          ' render.json > matrix.json; then
            echo "::group::render.json (first 2000 chars)"
            head -c 2000 render.json || true
            echo
            echo "::endgroup::"
            exit 1
          fi

          MATRIX=$(tr -d '\n' < matrix.json)
          echo "matrix=$MATRIX" >> "$GITHUB_OUTPUT"

  build:
    runs-on: ubuntu-latest
    needs: [env, prepare]
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.prepare.outputs.matrix) }}
    env:
      ANACONDA_PACKAGE: ${{ needs.env.outputs.ANACONDA_PACKAGE }}
      ANACONDA_VERSION: ${{ needs.env.outputs.ANACONDA_VERSION }}
      ANACONDA_LABEL:   ${{ needs.env.outputs.ANACONDA_LABEL }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup micromamba
        uses: mamba-org/setup-micromamba@v2
        with:
          micromamba-version: "latest"
          generate-run-shell: true
          cache-environment: true
          environment-file: |
            name: build
            channels: [conda-forge, defaults, hep-forge]
            dependencies:
              - python
              - conda-build
              - boa
              - anaconda-client
              - conda-package-handling
              - ccache
              - pkg-config
              - jq

      - name: Cache conda-bld
        uses: actions/cache@v4
        with:
          path: ~/micromamba/conda-bld
          key: conda-bld-${{ runner.os }}-${{ hashFiles('recipe/**') }}-${{ matrix.root }}

      - name: Configure ccache
        run: |
          set -e
          mkdir -p ~/.ccache
          {
            echo "max_size = 2G"
            echo "compiler_check = content"
          } > ~/.ccache/ccache.conf
          echo "CCACHE_DIR=$HOME/.ccache" >> "$GITHUB_ENV"
          echo "CCACHE_BASEDIR=$GITHUB_WORKSPACE" >> "$GITHUB_ENV"
          echo "CC=ccache gcc"  >> "$GITHUB_ENV"
          echo "CXX=ccache g++" >> "$GITHUB_ENV"
          echo "CMAKE_CXX_COMPILER_LAUNCHER=ccache" >> "$GITHUB_ENV"
          echo "CMAKE_C_COMPILER_LAUNCHER=ccache"   >> "$GITHUB_ENV"

      - name: Build (one CBC variant)
        shell: bash -l {0}
        run: |
          set -euo pipefail
          cat > variants.json <<JSON
{"root":["${{ matrix.root }}"],"c_stdlib":["${{ matrix.c_stdlib }}"],"c_stdlib_version":["${{ matrix.c_stdlib_version }}"]}
JSON
          echo "Selected variant: $(cat variants.json)"
          mamba mambabuild recipe --variants "$(cat variants.json)" --output-folder pkgs

          # Optional: convert tarballs to .conda for upload
          for PKG in $(find pkgs -name "*.tar.bz2"); do
            conda convert --platform linux-64 "$PKG" -o pkgs >/dev/null 2>&1 || true
          done

      - uses: actions/upload-artifact@v4
        with:
          name: conda-packages-${{ matrix.root }}
          path: pkgs/**/*
          if-no-files-found: error

  publish:
    runs-on: ubuntu-latest
    needs: [env, build]
    steps:
      - uses: actions/download-artifact@v4
        with:
          pattern: conda-packages-*
          merge-multiple: true
          path: pkgs

      - name: Setup micromamba (client)
        uses: mamba-org/setup-micromamba@v2
        with:
          micromamba-version: "latest"
          generate-run-shell: true
          environment-file: |
            name: upload
            channels: [conda-forge]
            dependencies:
              - anaconda-client

      - name: Upload to Anaconda
        env:
          ANACONDA_LABEL:   ${{ needs.env.outputs.ANACONDA_LABEL }}
          ANACONDA_PACKAGE: ${{ needs.env.outputs.ANACONDA_PACKAGE }}
          ANACONDA_VERSION: ${{ needs.env.outputs.ANACONDA_VERSION }}
          ANACONDA_API_TOKEN: ${{ secrets.ANACONDA_API_TOKEN }}
        shell: bash -l {0}
        run: |
          set -euo pipefail
          [ -z "$ANACONDA_VERSION" ] && exit 1
          find pkgs -type f -name "*.conda" -print0 | while IFS= read -r -d '' CONDA; do
            anaconda -t "$ANACONDA_API_TOKEN" upload --force "$CONDA" --label "$ANACONDA_LABEL"
          done
